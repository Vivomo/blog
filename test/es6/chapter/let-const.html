<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>let && const</title>
</head>
<body>

<h1>let && const</h1>
<dl>
    <dt>let命令</dt>
    <dd>ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</dd>
</dl>
<p>
    for循环的计数器，就很合适使用let命令。
</p>
<h2>特性</h2>
<ul>
    <li>不存在变量提升(error:ReferenceError)</li>
    <li>暂时性死区(temporal dead zone，简称 TDZ)</li>
    <li>不允许重复声明</li>
</ul>
<dl>
    <dt class="eg-error">
        只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响,
        “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</dt>
    <dd>
        <pre>
var tmp = 123;
if (true) {
    tmp = 'abc'; // ReferenceError
    let tmp;
}

typeof x; // ReferenceError
let x;
</pre>
    </dd>
</dl>
<dl>
    <dt class="eg-error">比较隐蔽的"死区"</dt>
    <dd>
        <pre>
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。


// 不报错
var x = x;

// 报错
let x = x;
        </pre>
    </dd>
</dl>

</body>
</html>