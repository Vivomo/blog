<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../css/cube.css"/>
    <script src="../js/avalon.js"></script>

</head>

<body>
<div ms-controller="cube" class="outer-wrap">

    <div class="outer-box">
        <div ms-repeat="cubes" class="cubes"
             ms-attr-id="'id_'+$index"
             ms-css-transform="translate3d({{el.x}}px, {{el.y}}px, {{el.z}}px) rotateX({{el.rotateX}}deg) rotateY({{el.rotateY}}deg) rotateZ({{el.rotateZ}}deg)"
             ms-css-transform-origin="{{el.originX}}px {{el.originY}}px {{el.originZ}}px"
        >
            {{el.x}},{{el.y}},{{el.z}} <br>
            {{el.rotateX}}, {{el.rotateY}}, {{el.rotateZ}} <br>
            {{side($index)}}
            <div class="front face" ms-css-background="bg($index,'front')"></div>
            <div class="left face" ms-css-background="bg($index,'left')"></div>
            <div class="up face" ms-css-background="bg($index,'up')"></div>
            <div class="right face" ms-css-background="bg($index,'right')"></div>
            <div class="back face" ms-css-background="bg($index,'back')"></div>
            <div class="bottom face" ms-css-background="bg($index,'bottom')"></div>
        </div>
    </div>

</div>
<script>

    Math.radian = function (degree) {
        return degree * Math.PI / 180;
    };

    const COLOR_MAP = {
        up: 'yellow',
        bottom: 'white',
        left: 'orange',
        right: 'red',
        front: 'blue',
        back: 'green'
    };
    const CUBE_WIDTH = 100;

    const CubeUtil = (() => {
        const front = 32,
            back = 16,
            up = 8,
            bottom = 4,
            left = 2,
            right = 1;
        return {
            front,
            back,
            up,
            bottom,
            left,
            right,
            xDirection: [front, up, back, bottom],
            yDirection: [front, left, back, right],
            zDirection: [up, right, bottom, left],
            getMarkObj: function (mark) {
                const markNum = typeof mark === 'number' ? mark : this.getBaseMark(mark);
                const markObj = {};
                ['front', 'back', 'up', 'bottom', 'left', 'right'].forEach((item) => {
                    markObj[item] = markNum & this[item];
                });
                return markObj;
            },
            createCubes: function() {
                return avalon.range(0, 27).map((index) => {
                    let x = (index % 3 - 1) * CUBE_WIDTH,
                        y = ~~(index % 9 / 3) * CUBE_WIDTH - CUBE_WIDTH,
                        z = ~~(index / 9) * CUBE_WIDTH - CUBE_WIDTH,

                        originX = this.getCubeOrigin(x),
                        originY = this.getCubeOrigin(y),
                        originZ = this.getCubeOrigin(z, true, index);

                    return {
                        index,
                        x,
                        y,
                        z,
                        originX,
                        originY,
                        originZ,
                        rotateX: 0,
                        rotateY: 0,
                        rotateZ: 0,
                    };
                })
            },
            getBaseMark: (cube) => {
                let mark = 0;
                if (cube.z == -CUBE_WIDTH)
                    mark |= CubeUtil.back;
                if (cube.z == CUBE_WIDTH)
                    mark |= CubeUtil.front;
                if (cube.x == -CUBE_WIDTH)
                    mark |= CubeUtil.left;
                if (cube.x == CUBE_WIDTH)
                    mark |= CubeUtil.right;
                if (cube.y == -CUBE_WIDTH)
                    mark |= CubeUtil.up;
                if (cube.y == CUBE_WIDTH)
                    mark |= CubeUtil.bottom;
                return mark;
            },
            getCubeOrigin: (translate, isZ = false, index) => {
                if (isZ) {
                    return index < 9 ? CUBE_WIDTH :
                        index < 18 ? 0 : -CUBE_WIDTH;
                }
                return -translate + CUBE_WIDTH / 2;
            },
            getSide: function (cube) {
                let markObj = this.getMarkObj(cube);
                let baseMark = this.getBaseMark(cube);

                if (cube.rotateX !== 0) {
                    this.xDirection.forEach((direction) => {
                        baseMark &= ~direction;
                    });
                    let rotateCount = cube.rotateX % 360 / 90;
                    Object.values(markObj).forEach((value) => {
                        let index = this.xDirection.indexOf(value);
                        if (index !== -1) {
                            baseMark |= this.xDirection[(index + rotateCount + 4) % 4];
                        }
                    });
                    markObj = this.getMarkObj(baseMark);
                }

                if (cube.rotateY !== 0) {
                    this.yDirection.forEach((direction) => {
                        baseMark &= ~direction;
                    });
                    let rotateCount = cube.rotateY % 360 / 90;
                    Object.values(markObj).forEach((value) => {
                        let index = this.yDirection.indexOf(value);
                        if (index !== -1) {
                            baseMark |= this.yDirection[(index + rotateCount + 4) % 4];
                        }
                    });
                    markObj = this.getMarkObj(baseMark);
                }

                if (cube.rotateZ !== 0) {
                    this.zDirection.forEach((direction) => {
                        baseMark &= ~direction;
                    });
                    let rotateCount = cube.rotateZ % 360 / 90;
                    Object.values(markObj).forEach((value) => {
                        let index = this.zDirection.indexOf(value);
                        if (index !== -1) {
                            baseMark |= this.zDirection[(index + rotateCount + 4) % 4];
                        }
                    });
                }

                return baseMark;
            }
        }
    })();


    let vm = avalon.define({
        $id: 'cube',
        cubes: CubeUtil.createCubes(),
        /**
         * 标记方块属于那一个边
         * 000000  前后上下左右
         * @param index
         */
        side: function (index) {
            return CubeUtil.getSide(vm.cubes[index])
        },
        bg: function (index, direction) {
            const cube = vm.cubes[index];
            const mark = CubeUtil.getBaseMark(cube);
            if (mark & CubeUtil[direction]) {
                return COLOR_MAP[direction]
            }
        },
        rotate: (direction, num, isClockwise = true) => {
            if (direction === 'x') {
                let cubes = vm.cubes.filter((cube) => {
                    let side = CubeUtil.getSide(cube);
                    if (num === 1) {
                        return side & CubeUtil.left;
                    } else if (num === 2) {
                        return !(side & CubeUtil.left) && !(side & CubeUtil.right);
                    } else {
                        return side & CubeUtil.right;
                    }
                });
                console.log(cubes.length);
                cubes.forEach((cube) => {
                    cube.rotateX += isClockwise ? 90 : -90;
                });
            } else if (direction === 'y') {
                vm.cubes.filter((cube) => {
                    let side = CubeUtil.getSide(cube);
                    if (num === 1) {
                        return side & CubeUtil.up;
                    } else if (num === 2) {
                        return !(side & CubeUtil.up) && !(side & CubeUtil.bottom);
                    } else {
                        return side & CubeUtil.bottom;
                    }
                }).forEach((cube) => {
                    cube.rotateY += isClockwise ? 90 : -90;
                });
            } else if (direction === 'z') {
                vm.cubes.filter((cube) => {
                    let side = CubeUtil.getSide(cube);
                    if (num === 1) {
                        return side & CubeUtil.front;
                    } else if (num === 2) {
                        return !(side & CubeUtil.front) && !(side & CubeUtil.back);
                    } else {
                        return side & CubeUtil.back;
                    }
                }).forEach((cube) => {
                    cube.rotateZ += isClockwise ? 90 : -90;
                });
            }

        }
    });
    avalon.scan();


</script>
</body>
</html>