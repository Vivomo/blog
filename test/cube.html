<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../css/cube.css"/>
    <script src="../js/avalon.js"></script>

</head>

<body>
<div ms-controller="cube" class="outer-wrap">

    <div class="outer-box">
        <div ms-repeat="cubes" class="cubes"
             ms-attr-id="'id_'+$index"
             ms-css-transform="translate3d({{el.x}}px, {{el.y}}px, {{el.z}}px) rotateX({{el.rotateX}}deg) rotateY({{el.rotateY}}deg) rotateZ({{el.rotateZ}}deg)"
             ms-css-transform-origin="{{el.originX}}px {{el.originY}}px {{el.originZ}}px"
             ms-attr-data-role="role($index)"
             ms-attr-data-side="side($index)"
             ms-attr-data-position="position($index)">
            {{el.x}},{{el.y}},{{el.z}} <br>
            {{el.rotateX}}, {{el.rotateY}}, {{el.rotateZ}}
            <div class="front face" ms-css-background="bg($index,'front')" ></div>
            <div class="left face" ms-css-background="bg($index,'left')"></div>
            <div class="up face" ms-css-background="bg($index,'up')"></div>
            <div class="right face" ms-css-background="bg($index,'right')"></div>
            <div class="back face" ms-css-background="bg($index,'back')"></div>
            <div class="bottom face" ms-css-background="bg($index,'bottom')"></div>
        </div>
    </div>

</div>
<script>

    Math.radian = function(degree) {
        return degree * Math.PI / 180;
    };
    let cos = function(degree) {
        return Math.cos(Math.radian(degree));
    };
    let sin = function(degree) {
        return Math.sin(Math.radian(degree));
    };

    let colorMap = {
            up : 'yellow',
            bottom : 'white',
            left : 'orange',
            right : 'red',
            front : 'blue',
            back : 'green'
        },
        cubes = [],
        up = [],
        bottom = [],
        left = [],
        right = [],
        front = [],
        back = [],
        l = 100;



    let CubeUtil = {
        edge : 8,
        horn : 4,
        center : 2,
        core : 1,
        front : 32, // 100000
        back : 16, //  010000
        up : 8,
        bottom : 4,
        left : 2,
        right : 1,
        hornIndexArr : [0,2,6,8,18,20,24,26], //为了避免方法调用时,总要生成一个新的数组
        centerIndexArr : [4,10,12,14,16,22], //同上
        isEdge : function(index) {
            return index % 2 != 0 && index != 13;
        },
        isHorn : function(index) {
            return CubeUtil.hornIndexArr.indexOf(index) != -1;
        },
        isCenter : function(index) {
            return CubeUtil.centerIndexArr.indexOf(index) != -1;
        },
        isCore : function(index) {
            return index == 13;
        }
    };



    for (let index = 0; index < 27; index++) {
        let x = (index % 3 - 1) * l,
            y = ~~(index % 9 / 3) * l - l,
            z = ~~(index / 9) * l - l;

        let originX = getOrigin(x),
            originY = getOrigin(y),
            originZ = getOrigin(z, true, index);

        let item = {
            index,
            x,
            y,
            z,
            originX,
            originY,
            originZ,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
        };
        cubes.push(item);
        initCube(item);
    }

    function getOrigin(translate, isZ = false, index) {
        if (isZ) {
            return index < 9 ? l :
                index < 18 ? 0 : -l;
        }
        return -translate + l / 2;
    }

    let vm = avalon.define({
        $id: 'cube',
        cubes: cubes,
        up : up,
        bottom : bottom,
        left : left,
        right : right,
        front : front,
        back : back,
        transform: avalon.range(0, 27).map(function () {
            return 'translate3d(0px, 0px, 0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg)';
        }),
        getTransform: function (index) {
            return vm.transform[index];
        },
        /**
         * 标记方块的角色 二进制标识位
         * 1000 棱 (8)
         * 0100 角 (4)
         * 0010 中心(2)
         * 0001 核心(1)
         * @param index
         */
        role : function(index){
            if ( CubeUtil.isEdge(index))
                return CubeUtil.edge;
            if ( CubeUtil.isHorn(index))
                return CubeUtil.horn;
            if ( CubeUtil.isCenter(index))
                return CubeUtil.center;
            if ( CubeUtil.isCore(index))
                return CubeUtil.core;
        },
        /**
         * 标记方块属于那一个边
         * 000000  前后上下左右
         * @param index
         */
        side : function(index) {
            let temp = 0;
            let cube = cubes[index];
            if (cube.z == 50)
                temp |= CubeUtil.back;
            if (cube.z == 250)
                temp |= CubeUtil.front;
            if (cube.x == 0)
                temp |= CubeUtil.left;
            if (cube.x == 200)
                temp |= CubeUtil.right;
            if (cube.y == 0)
                temp |= CubeUtil.up;
            if (cube.y == 200)
                temp |= CubeUtil.bottom;
            return temp;
        },
        position : function(index) {

        },
        bg : function (index, key) {
            let arr = vm[key];
            for (let i = 0; i < arr.length; i++) {
                if (arr[i].index === index)
                    return colorMap[key]
            }
        }
    });
    avalon.scan();


    function initCube(item){
        if (item.index < 9) {
            back.push(item);
        }
        if (item.index > 17) {
            front.push(item);
        }

        var m = item.index % 3;
        if (m === 0) {
            left.push(item);
        } else if (m === 2) {
            right.push(item);
        }

        var m2 = item.index % 9;
        if (m2 < 3) {
            up.push(item);
        } else if (m2 > 5){
            bottom.push(item);
        }
    }


</script>
</body>
</html>