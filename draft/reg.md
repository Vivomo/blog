`[]` 字符组
只有`-`才是元字符, 其他元字符在`[]`中无需转义, 且`-`只有在字符组里面才是元字符

#### 单词边界符
`\<`和`>/` 对应JS中的`\b`
单个字符为非元字符, 与斜线组合起来才具有特殊意义的为元字符序列

#### 括号及反向引用
括号匹配成功后 会产生$1, $2, $3之类的变量

`/(cat)9\1/` -> `cat9cat`

#### 引号内的字符串
`/"[^"]"/`

#### 非捕获型括号
`(?:)` 不会保存变量

#### 命名捕获
`(?<name>)`
"abc".replace(/(?<m>a)/, "$<m>-") // "a-bc"，同样 $1 仍然可用

#### 环视
`/\w+(?=\.txt)/` => `abc.txt` 
相反的`(?!...)`


#### 性能
`[ab]` 优于 `(a|b)`

#### js 不支持的正则
>. `(?<=)`
>. `[[a-z]-[c-f]]` 区间减法 .net
>. `(?#...)` VB 添加注释

### 引擎的分类

> DFA (文本主导) 确定型有穷自动机
> NFA (表达是主导)
js 是NFA

`/to(nite|knight|night)/`

### 引擎的构造
>. 文字文本
>. 字符组
>. 捕获型括号
>. 锚点
>. 括号, 反向引用, 忽略优先量词

### 匹配规则
>. 优先选择最左端的匹配结果
>. 标准量词是优先匹配的

#### 回溯的要点
如果需要在 "进行尝试" 和 "跳过尝试" 之间选择, 
对于匹配优先量词 -> 尝试 / or not, not

距离当前最近储存的选项就是当本地失败强制返回的(LIFO)

#### 平衡法则
>. 只匹配期望的文本,排除不期望的文本
>. 易于控制和理解
>. if NFA, 必须保证效率

#### 打造高效正则表达式
>. 多选分支的调序 /([\u0255-\u6500]|\w)/
>. 减少回溯 `/".+?""/` -> `/"[^"]+"/`

#### 重构的巧用
`([A-Z][a-z]*)`  `-\L$1`  => replace 驼峰类名转破折号小写

### link
[构造正则表达式引擎](http://www.cppblog.com/vczh/archive/2008/05/22/50763.html)
[在线测试](http://regex.zjmainstay.cn/)
[正则生成器](http://www.txt2re.com/index.php3)

```js
reg = new RegExp(`^[0369]* (
                     (
                       [147][0369]*
                     | [258][0369]*[258][0369]*
                     ) ([147][0369]*[258][0369]*)* (
                       [258][0369]*
                    
                     | [147][0369]*[147][0369]*
                     )
                   | [258][0369]*[147][0369]* )* $`)
                   
```

### 编辑器的技巧

搜索可以使用正则搜索
替换文本时, 前面添加\u\l\U\L可以将捕获的进行大小写转换


